


┌──────────────────────────────────────────┐
│	○: 해결		X: 미해결		△: 임시해결		□: 미제사건       │
└──────────────────────────────────────────┘

┌──────────────────────────────────────────────────*자 세*───────────────────────────────────────────────────┐
│문제에 대해 근본적으로 해결을 하려고 하자. / 일부만 수정하여 그 문제를 넘기려 하지 말자. / 침착하게 무엇때문에 오류가 발생하는지 파악 하여 대응하자.       					  │
│그 함수를 보며 내가 처리한 과정을 다시 적어보면 빠트린 상황이 언제이고 어디에 추가 되어야 할지 알 수 있다.									     					  │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────*규 칙*───────────────────────────────────────────────────┐
│scrollFlags가 SF_NORMAL인 상황이더라도 longestRow 이전의 줄 수가 바뀌는 상황이면 longestRow값 수정 필요								    					  │
│Document::Delete는 업데이트가 이뤄져 있는 상황을 가정하에 실행된다. (메세지 박스를 추가해두자.) 그리고 실행 후에는 업데이트가 완료 된 상태이다.	    					  │
│Document::CountRows는 업데이트가 이뤄져 있는 상황을 가정하에 실행된다.																							│
│Paper::RowWrap 함수를 호출할 때 종이에서 현재줄의 위치에 따라 따라 종이에서 현재줄이 변경된다. 그러므로 상황에 따라 줄에서 현재위치를 이동 해놓고 이 함수를 호출한다.	  │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────*메 모*───────────────────────────────────────────────────┐
│ScrollUp, Down이 발생하는 상황 : 스크롤을 움직였을 때, 확대축소를 할 때		 																			  │
│MemoryController::Save가 이뤄지고 MoveUp 이나 MoveDown이 이뤄지지 않았을 때 Document::end를 Document::start + paper.rowCount-1로 업데이트를 해줘야한다.	  │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────┘
2024-02-04 01:43
세번클릭시 줄 선택하는 처리과정을 먼저 적어보자.
TextEditor에서 isContinuous 속성을 추가한다.
더블클릭 메세지를 받았을 때 isContinuous = TRUE 이다.
MouseMove나 MouseWheel, RButtonDown 메시지를 받았을 때는 isContinuous = FALSE로 고친다.
Shift+LButtonDown일때도 isContinuous를 FALSE로 고친다.

세번클릭 메시지를 보내는 조건에 isContinuous가 TRUE일 때도 추가한다.

자동줄바꿈 상태이면 현재줄을 자동줄바꿈 해제한다.
현재 줄이 몇 번째 row인지 구한다. (Document::GetRowNumber() 를 하면 구할 수 있다.)
선택영역 Previous와 Current를 정한다.
선택한다.
Document에서 선택영역을 업데이트한다.
현재 위치를 줄의 마지막으로 이동한다.
자동줄바꿈 상태이면 현재줄을 자동줄바꿈한다.



2024-02-02 07:53
선택영역을 표시할 때 영역에 사각형을 그리고 그 위에 투명으로 문자를 출력하면 선택영역도 문자겹침없이 출력이 가능할 것으로 보인다.

2024-01-17 21:33
세번 클릭 아이디어
한번 클릭시 시간을 저장한다.
더블클릭시 시간을 저장한다.
한번 클릭시 더블클릭 했던 시간을 확인한다.
사이의 텀이 정해져 있는 것보다 짧으면
TripleClicked으로 Message를 보낸다.
::GetDoubleClickTime이라는 API함수로 사용자가 윈도우에서 설정한
더블클릭 시간을 구할 수 있다.
마우스Move시 또는 우클릭 시,마우스휠 시 카운트는 0이 된다.
준비
0. API함수로 더블클릭 시간을 구해 놓는다.
1. 현재 시간을 저장해놓는다.
2. 더블 클릭 시 시간을 저장한다.
한번 클릭 시
1. 시간을 잰다.
2. 더블 클릭 시 저장한 시간과 비교한다.
3. 더블클릭 시간보다 한번 클릭시 이벤트를 실행한다.
4. 더블클릭 시간보다 짧으면 Triple클릭을 실행한다.

더블클릭 시간 변수를 선언한다.(초기화 필요)
LButtonClicked
1. 시간을 구한다.
2. 더블클릭과 시간 차이를 구한다.
3. 두 번 클릭 속도보다 작으면 세 번 클릭 커맨드를 실행한다.	



2024-01-09 23:29
* 계획
한 줄만 Invalidate
클릭상태에서 드래그
세번클릭

<1> 코드정리
현재 코드가 많이 지저분하다. 디자인패턴을 적용하여 클래스를 나누고 코드를 정리할 필요가 있어 보인다.
우선순위는 UnDoReDoCommand에 상속받는 Command가 isNew의 TRUE와 FALSE에 따라 내용이 너무 길어진다.
클래스를 나누어 보면 더 좋을 것 같은데 거기에 따라 많은 구조 변경이 필요하다.
일단 이게 1번으로 처리를 하는게 좋을 것 같고 테스트 시나리오를 매일 다듬자.

* 논리오류
시작할 때 데이터파일 지우는것이 Primaery code로 작성 되어 있기 때문에 시작 시 데이터 파일 지우는것이 안되고 있다. 방법을 찾아보자.
줄의 한계 2048

* 기능
클릭상태에서 드래그하기
다크모드
PasteFromFile 속도개선
tmp파일 제목에 날짜도 넣자.

* 공간복잡도

* 시간복잡도
1. SelectedTextOutVisitor
└>  출력을 시작할 줄과 출력을 끝낼 줄이 Row단위로 선택 시작줄과 선택이 끝나는 줄 사이이면 SelectedTextOutVisitor를 생성하고 호출하자.
//onpaint에서 CPaintDC를 다른곳에 할당해서 저장 해놓고 font에 대해서는 폰트를 변경할 때마다 적용 해주는 방법으로 고치면 더빨라지지 않을까?

Visitor가 2개 이기 때문에 같은 계산이 되는것을 줄일 수 있다.
└> 몇번 째 줄부터 몇번 째 줄까지 출력을 하면 되는지는 공통적으로 구하고 있다.
└> 줄에서 몇번 째 칸부터 몇번째칸 까지 출력이 되는지는 Visitor마다 계산이 되고 있어 저장해두면 두번째에서 또 안해도 된다.

가장 긴 줄에서 OnCharCommand 후 실행취소 했을 때 전체 줄에서 가장 긴 줄을 다시 찾는데 Excute시에 미리 저장을 해두면 좋을 것 같다.

찾기 할 때 찾을내용의 문자가 ASCII인지 아닌지 미리 구해서 배열에 저장을 해놓고 하면 수를 줄 일 수 있지 않을까? 자동줄바꿈 상태에서
줄 길이가 줄 너비가 보다 작다면 자동줄바꿈이 필요가 없다.
자동줄바꿈함수에서 조건식을 추가하여 실행횟수를 줄일 수 있을것으로 보인다.

1. 자동줄바꿈 첫 실행 시 스크롤이 붙으면 여러번 실행이 될 수 있다. 이런경우 미리 차단 하여 실행횟수를 줄일수 있으니 차 후 생각해보자.
2. Delete 관련해서 OnSize가 너무 많이 일어나고 있는것 같아 확인 필요.
SF_COMEPARE이 한 줄에 대해서만 변동이 있을 때 쓰는 플래그 인데 이 줄이 만약 longestRow이면서 
더 짧아진다면 전체 줄에서 다시 longestRow를 찾아야 하는 상황으로 보인다. 하지만 현재 그렇게 구현되어 있지 않음.
먼저 더 짧아진다면 전체 줄 에서 다시 longestRow를 찾는 방법으로 고치긴 했으나, 한글을 입력할 떄 또는 지울때 너무 느리다.
개선책은 두번째로 가장긴줄도 구해 놓는것은 어떠한가 나중에 필요시 더 자세히 연구해보자

화면내 출력될 내용이 많은 경우 굉장히 느려진다.
Visitor로 인해 꼭 전체내용을 다시 출력해줄 필요가 있는것은 아닐텐데.. 생각이 좀 필요할 것 같다.

스크롤포지션이나 창크기가 변경 되었을 때는 전체 / 그게 아닌경우는 복사나 한꺼번에 지우기 등은 여러줄 재출력 필요.. 더 생각할 필요가 있따.

* 기타
형상관리, 주석, 프레임워크 그리기
SetPosition할 때도 조건을 주어 필요한 상황에서만 할 수 있도록 / 스크롤컨트롤러 클래스에서 Update와 SetPosition 알고리듬 수정 / 스크롤 세부조정
마우스 휠 미끄럼틀처럼 만들어보기
메모장프로젝트일지를 키고 전체선택 후 지웠다가 되돌리기를 하였을 때 스크롤이 마지막까지 가지 않는다.
└>  원인: 가로스크롤이 생기면서 클라이언트 크기가 변경되어 세로스크롤 Page값이 변경되어 그렇다. 다른 이벤트를 진행하면 맞춰진다.

2024-01-09 23:30
<<완료>>
SelectingRightKeyAction, SelectingLeftKeyAction에서 무한 반복이 있다. 로그를 남길 때 반복문 시작전에 변경식에 대한 정보들과 함께 남기자. 로그를 남길 때 현재 줄, 칸도 적어서 재현할 때 참조가 될 수 있도록 하기.

<<완료>>
더블클릭 시 선택되도록

2023-12-30 11:26
<<완료>>레지스트리
-폰트정보
-자동줄바꿈 여부
-상태표시줄
-윈도우 크기
-윈도우 위치

<<완료>>선택상태에서 찾기시에 선택된 내용이 찾기 다이얼로그 찾을 내용에 들어가도록

2023-12-27 22:04
<<완료>> log에 KeyAction, OnClose 들어가도록 고치기.

2023-12-26 09:32

2023-12-16 10:03
<<완료>> 위 아래 좌 우 여백 설정
<<완료>> 테스트 시나리오 작성 (자동줄바꿈상태, 잘라내기, 붙여넣기, 삭제, 실행취소, 재실행 기능 위주)
└>자체적으로 테스트를 해보았으나 오류를 찾지 못함.

2023-12-14
<<완료>> 로그 경로 Programdata에서 log파일 생성하기

2023-12-13 23:07
<<완료>> 저장 시 임시저장파일 만들기

2023-12-11 15:02
* 계획
<1> 로그 및 저장 시 임시저장파일 만들기
경로 Programdata에서 log파일과 

<2> 코드정리
현재 코드가 많이 지저분하다. 디자인패턴을 적용하여 클래스를 나누고 코드를 정리할 필요가 있어 보인다.
우선순위는 UnDoReDoCommand에 상속받는 Command가 isNew의 TRUE와 FALSE에 따라 내용이 너무 길어진다.
클래스를 나누어 보면 더 좋을 것 같은데 거기에 따라 많은 구조 변경이 필요하다.
일단 이게 1번으로 처리를 하는게 좋을 것 같고 테스트 시나리오를 매일 다듬자.

2023-11-28 21:05
<<완료>>메모장 선택상태 + F5 매크로커맨드 만들기 MAX 4096으로 늘려놓기

오전 11:13 2023-11-20
<<완료>> 마우스 클릭 중 이동으로 스크롤 가능하도록 변경완료
<<완료>> 클라이언트 여러개 실행 시 각각의 데이터 파일 생성되도록 변경
<<완료>> 종료 시 글꼴, 자동줄바꿈 상태 저장 및 다음 실행 시 마지막 설정 대로 실행
<<완료>> Ctrl+W키로 종료하기.


오후 3:45 2023-11-17
<<완료>>F5 시간 나타나는 기능 추가하기
<<완료>> txt 파일을 연결프로그램으로 실행 시 열기, 더블클릭으로 txt파일 열기

오전 11:53 2023-10-27
캐럿콘트롤러에 대해 메모리 누수가 발생했는데, KillFocus시에 할당해제가 되도록 되어있는데
KillFocus가 발생하지 않고 프로그램이 종료되는 일이 발생하였다. 원인은 찾지 못함.

오후 4:30 2023-10-25

오후 12:11 2023-10-23
안쓰는 함수를 지운 후에 Ctrl+F시에 논리오류가 발생하며, 이유는 Composite의 GetLength가 호출이 잘 안되보인다.
└> Release 모드에서 디버그 모드로 실행해서 발생한 문제였으며 Debug모드로 변경하고 확인하니 문제가 없다.

오후 3:46 2023-10-19
클래스들에서 사용하지 않는 함수를 찾아서 지우고 그 후에 클래스다이어그램을 정리하자.
지운 함수 목록
1. Document
 - Add
- Removejj
2. Paper
  - RemoveSelectedRows
  - virtual void Select(Long row, Long column);
  - virtual void MoveSelectingStartPoint();
  - virtual void MoveSelectingEndPoint();
  - virtual bool FindNext(string findWhat);
3. Row
  - RemoveSelectedTexts

오전 9:19 2023-10-18
<<○>>
먼저 기존의 것들을 그대로 TextOut API함수를 이용해서 출력한다. 특정 ASCII(소문자)코드는 DrawText를 이용해서 출력한다.(기존에 TAB 문자를 출력해주고 있는것 처럼)
TextOutVisitor와 SelectedTextOutVisitor는 알고리즘을 동일하게 변경해준다.
└> 문자겹침 Trimmed 현상이 발생했었는데 TextOut시 배경을 투명처리 하여 겹침 문제가 발생하지 않도록 되었다.

오전 11:46 2023-10-17
<<○>>
시작할 때 tmp파일 모두 지워주기.
└> TextEditor::OnCreate에서 fileMaker::New를 실행하기 전에 Remove를 실행하여 미리 지워주고 시작한다.

문서작업 시작

오전 9:50 2023-10-13
<<○>>
TextOut으로 영어 소문자를 출력 시 겹침현상 발생
└> TextOut API함수 대신 DrawText 사용 및 특정 알파벳 넓이를 이탤릭체인 경우 추가로 조정해주었습니다.

오전 9:27 2023-10-12
<<○>>
줄 이동 기능에서 MemoryController::Save 후에 Document::End값이 업데이트가 되지 않아 줄 수가 맞지 않는 문제가 발생했다.
MemoryController::Save가 이뤄졌을 때 Document::start, end값이 기본적으로 업데이트가 되지 않으면 문제가 발생할 수 있다.
기본적으로 MoveUp이나 MoveDown을 바로 하기 때문에 Save자체에 start와 end값은 변경이 되지 않는다.
└> MoveForm에서 이동 버튼 클릭시 MoveUp이나 Down을 하지 않아도 End값이 변경되도록 코드를 변경하였다.

<<○>>
자동줄바꿈 시 ScrollUp, ScrollDown시에 문제가 있다.
1. Document::CountRows 함수에서 변수 line에 대해 언더, 오버플로우가 발생할 수 있다.
2. ScrollController::diskFileVSMax가 변경될 수 있다.
└> Document::CountRows 함수는 현재 항상 isUpdated가 참인 경우에만 호출이 되고 있어 오버플로우는 Document::length를 넘지 않도록, 언더플로우는 1보다 작지 않도록 코드를 수정하였다.
└> 자동줄바꿈 상태이면 ScrollUp, Down시 메모리에서 삭제 및 추가되는 줄 수가 달라질 수 있어 diskFileVSMax값이 변경된다. 그에 따라 업데이트가 되도록 코드를 수정하였다.

<<○>>
Shift+LButton 이벤트가 발생했을 때 isScrolling이 참이고 previous위치가 종이 밖에 있다면 종이의 특정 지점(처음 또는 마지막)으로 이동하여 선택하기를 해주고 있다.
이 과정에서 시작줄은 선택이나 선택해제가 되지 않는 문제가 있다.
└> 줄선택을 수기로 처리를 해주는 코드를 추가하여 해결

오전 10:05 2023-10-11
잎사귀 테스트 진행

오후 3:59 2023-10-09
<<○>>
Shift + 마우스 왼쪽클릭 선택기능 구현 완료.

오전 9:51 2023-10-06
<<○>>
ReplaceFind 재실행시 FindNextCommand가 실행되도록 되어 있어서 문제가 있었습니다.
└> isNew조건문을 넣어 재실행시 FindNextCommand가 실행되지 않게 수정하게 해결

<<○>>
바꾸기 후 Scrolling 하여 isScrolling이 참 일때, 실행취소를 하면 기존 선택영역 선택해제가 되지 않는다.
└> isScrolling이 참일 때 TextEditor::GetBack을 호출함으로 해결되었습니다.

<<○>>
선택영역이 종이 외부에서 부터 종이 내부까지 있을때 삭제 후 실행취소 및 재실행시 데이터가 그대로 원복되지 않는 문제가 있다.
문제가 발생하는 상황을 정확히 특정하자.
①. (1,1) ~ (101,1)까지 선택(Start: 2 / End: 101) → 삭제 → 실행취소 → 내용확인 → 문제없음
<<해결>>②. (1,2) ~ (101,1)까지 선택(Start: 2 / End: 101) → 삭제 → 실행취소 → 내용확인 → 문제있음 (마지막 줄 특수문자)
<<해결>> ③. (1,2) ~ (101,1)까지 선택(Start: 2 / End: 101) → 삭제 → Scrolling → 내용확인 → 문제있음(첫째줄에 '습'이 아니라 '싱'이 적혀있음)
<<해결>>④. (1,2) ~ (101,1)까지 선택(Start: 2 / End: 101) → 삭제 → Scrolling → 실행취소 → 내용확인 → 문제있음(이상한 문자 적혀있음)
2번, 3번 그리고 4번 시나리오를 디버깅하여 문제를 찾자.
일단 지우고 난 뒤에 데이터 보관 tmp 디스크파일을 열어보니 첫번째 줄에 내용이 잘못 저장되어 있는것이 확인된다. (이 부분을 디버깅해보자)
└> Document::Delete함수에서 파일포인터에 대해 잘못처리를 했다.fseek(temp, 2, SEEK_CUR); 를 추가함으로써 해결되었습니다.

<<○>>
테스트문서 습도(UTF16-LE)에서 OnImeCompositionSelecting 기능 테스트 중 종이밖에서 
1. Position(170,3) ~ Position(170,4) / ㄱ
2. Position(195,1) ~ Position(200,1) / ㄴ
3. Position(300,1) ~ Position(302,2) / ㄷ
4. Position(1,1) ~ Position(15,5) / ㄹ
실행 후 종이밖에서 실행취소 시 3번 실행취소할 때 Document::Move에서 논리오류 발생한다.
└> isScrolling이 참일 때 TextEditor의 GetBack이 이뤄지기 때문에 Document의 end값이 고쳐지는데 조건식에 그렇지 않게 되어 있어서 수정 후 해결되었습니다.
└> if (this->row < this->textEditor->document->GetStart() || this->row > this->textEditor->document->GetStart() + this->textEditor->note->GetRo

<<○>>
테스트문서 습도(UTF16-LE)에서 OnImeCompositionSelecting 기능 테스트 중 종이밖에서 1. Position(170,3) ~ Position(170,4) / ㄱ , 2. Position(195,1) ~ Position(200,1) / ㄴ
실행 후 1번에 대해 실행취소 시 무한반복 발생한다.
└> isScrolling이 참일 때 TextEditor의 GetBack이 이뤄지기 때문에 Document의 end값이 고쳐지는데 조건식에 그렇지 않게 되어 있어서 수정 후 해결되었습니다.
└> if (this->row < this->textEditor->document->GetStart() || this->row > this->textEditor->document->GetStart() + this->textEditor->note->GetRowCount() - 1) {

<<○>>
OnImeCompositionSelecting에서 재실행시에 Document::Delete가 호출되는 경우가 있는데 이 함수는 isUpdated가 참인 상황에서만 호출되어야 하는데
그렇지 않아 오류가 발생하였다.
└> 조건식을 추가하여 update가 되지 않은 상황에서는 update를 하고 호출하도록 고쳐주었다.

오전 9:32 2023-10-05

<<○>>
OnImeCompositionSelecting에서 실행 취소시에 기존 선택영역이 선택해제 되지 않는 문제가 있다.
재실행시에는 문자가 두번씩 적히는 문제가 있다.
└> 실행취소시에는 isScrolling이 참인 상태에서는 TextEditor::GetBack 이후 선택해제 되도록 처리하여 해결하였다.
└> 재실행시에 두번씩 적히는 문제는 OnImeComposition에서 isNew에 대한 조건문이 있지 않아 발생하여 조건문을 추가하였다.

<<○>>
Delete::Execute 재실행시에 논리오류가 발생한다.
이유: Document::Delete와 Paper::Delete 함수를 사용하는데 이때 Document::startPosition과 endPosition값을 사용하나, 재 실행 시 이 값들을 바꿔주지 않았다.
└> Document의 startPosition과 endPosition을 재실행시 생성된 커맨드에 저장된 영역으로 고쳐줌으로써 해결했습니다.

<<○>>
RowDeleteKeyCommand::Execute 재실행시에 저장된 위치가 아니라 그 다음줄(지울 줄)이 종이내에 없을 경우 MoveUp / MoveDown을 해야하는데 그렇지 않아 오류가 발생했다.
└>this->row + 1 > this-> textEditor->document-> GetStart() + this->textEditor-> note->GetRowCount() - 1 / 조건식을 수정해주면서 해결.

<<○>>
줄 이동시에 Save가 이뤄지지만 이동하는곳이 Document::start ~ Document::end 사이라면 isUpdated는 TRUE가 되지만 start와 end값이 변경되지는 않았다.
하지만 그런 경우에 변경이 되지 않으니, 추후 MemoryController::Save를 할 때 Document::length 계산이 틀려지게 되는 오류가 생기게 되었다.
└>MemoryController::Save가 이뤄지고 Document::end값이 Document::start + paper.rowCount-1로 변경되도록 처리하였다.

<<○>>
종이밖에서 OnCharCommand::Execute 에서 this->row와 this->column 에 잘못된 값이 입력되기 때문에 그에 따라 실행취소시 오류발생한다.
또한 OnImeComposition or OnImeChar 도 확인이 필요해보인다.
└>  isScrolling이 참이면 TextEditor::GetBack을 해주면서 해결

오전 10:09 2023-10-04
<<○>>
습도(UTF-16 LE) 문서 첫째줄 '도' 문자를 종이 밖에서 복사했을 때 클립보드에 "도" 형태로 나타난다.
└>Document의 Copy함수 / 변수j 초기화 해줌으로써 해결

<<○>>
습도(UTF-16LE)파일에서 195~220번째 줄까지 선택 후 잘라내기 한 다음 종이 밖에서 실행취소를 하는경우 선택영역에 대한 표시에 오류가 있다.
지금 오류가 있는 기능은 종이밖에 있는줄중에서도 종이의 마지막줄 바로 다음줄이 선택되어 있는 상황을 고려하여 아래와 같은 식이 있다.

	if (this->textEditor->document->GetEnd() < this->textEditor->document->GetLength() &&
		this->textEditor->document->GetEnd() + 1 > this->textEditor->document->startPosition.row &&
		this->textEditor->document->GetEnd() + 1 <= this->textEditor->document->endPosition.row) {
		row = paper->GetAt(paper->GetLength() - 1);
		this->dc->TextOut(row->GetRowLength()-this->hSPosition, this->y, " ");
	}
먼저 Document::end가 마지막이 아니면서, end+1이 선택영역 시작줄 보다 크고, 선택영역 마지막줄 보다 작거나 같으면 해당줄이 선택된 줄이라고 보고 선택표시를 해주는것이다.
그렇지만 현재 업데이트가 되지 않은 상황으로 이 식이 언제나 맞는건 아니다. 그러므로 isUpdate의 값과 관계 없이 언제나 맞는 식으로 고쳐주어야 할 필요가 있다.
첫번째 식은 변경할 필요가 없어보인다. / 두번째와 세번째 식은 변경이 필요해 보인다. GetStart() + rowCount + 1 로 고치자.

<<○>>
PasteCommand 실행 시 줄 수가 많아 수직스크롤이 생성되면 Onsize가 호출되면서 Y좌표가 일치하지 않게 되는데 Onsize내에 UpdateFileVSInfo 함수 위치를 옮기고,
PasteCommand 함수에서 UpdatePosition을 한번 더 실행하면서 해결.

<<○>>
붙여넣기 후 실행취소 시 Document::Delete함수를 사용하는데 이 때 호출 시 매개변수로 Document::startPosition을 입력받는다. 이때 이전에 선택한적이 없다면 startPosition은 (-1,-1)
이기때문에 오류가 발생한다. 이때는 지울 영역이 선택영역은 아니기 때문에 PasteCommand::Unexecute에서 임의로 startPosition과 endPosition을 변경해주고 Document::Delete를
실행하여 해결하였다.

오전 11:21 2023-09-27
<<○>>
자동줄바꿈 이후 줄선택이 되었을 때 DummyRow의 마지막에 줄 선택 표시가 되지 않고 있다.
└> SelectedTextOutVisitor 고쳐주며 해결

오전 9:51 2023-09-26
<<○>>
바꾸기 시에 찾기 옵션도 적용되어야 한다. 지금 적용 안되어 있음(대소문자 구분, 단어단위로)

오전 10:04 2023-09-25
<<○>>
내용 중 일부 Delete 후 수직스크롤 최대값 업데이트 VSThumbTarackDown시 더 많이 내려간다.
MemoryController::ScrollUp / ScrollDown이 isUpdated가 참인 경우에만 실행을 하도록 되어 있지만, 이때 Document의 start와 end는 업데이트가 되어있지 않다.
└>그렇기 때문에 이 과정에서 계산이 맞지 않게 되었는데 ScrollUp / Down에서 start와 end값이 업데이트가 되지 않은 사실을 바탕으로 코드를 수정하여 해결하였다.

오후 4:43 2023-09-22
<<○>>
마우스 LButton클릭 시 선택해제 되도록 처리를 해야한다. 다양한 선택상황에서 해제 되도록 처리완료

오전 11:50 2023-09-19
잘라내기 후 실행취소 했을 때 맨 밑에 내용이 짤린다.

오전 9:28 2023-09-15
<<O>>
닫기버튼 눌렀을 때 저장 메세지박스

<<O>>
메모장프로젝트 일지 파일을 열고 아래로 내려서 확대 후 축소 시 칸 위치가 변경되며 오류가 발생한다.
└> 문서를 확대 축소를 하다보면 ScrollUp과 ScrollDown이 발생한다. 그래서 기존의 줄과 칸이 변경이 되는데 ScrollUp/Down하여 메모리내 데이터가 변경되었을 때
원래의 줄을 포함하고 있다면 해당 줄로 현재위치를 업데이트 해주는 방향으로 수정해보자. (isScrolling이 아닌상태에서만!)

<<○>>
축소 시에 수평스크롤 최대값이 변경되지 않는다.
└> SaveRowLength 함수에서 파일에서만 변경이 되도록 되어 있어 메모리 내 줄들의 속성값도 변경이 되도록 수정하였습니다.

오전 9:30 2023-09-14

<<○>>
자동줄바꿈 상태에서 isScrolling이 참일 때 상태표시줄에서 Row형태로 값이 나타나고 있다.

<<○>>
isScrolling 상태에서 선택하기 ShiftPageUp, ShiftPageDown시 논리오류 발생
└> 발생 사유는 isScrolling이 참이면 TextEditor::GetBack을 하는데 이 때 수직스크롤 값들과 포지션이 변경이 되는데
거기에 맞게 업데이트를 하지 않아 발생한 문제 입니다. 업데이트를 하고 알고리즘을 그대로 실행하니 문제가 해결되었습니다.

<<○>>
마우스 관련 이벤트 정리 후 고치기
- TextEditor::OnLButtonDown(UINT nFlags, CPoint point)
- TextEditor::OnMouseMove(UINT nFlags, CPoint point)
- TextEditor::OnLButtonUp(UINT nFlags, CPoint point)
- TextEditor::OnMouseLeave()
- TextEditor::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
- 속성 TextEditor::isClicking

<<○>>
빈 종이에서 아래로 드래그 시 뻑이 난다.
└> 언더플로우 막으면서 해결.

<<○>>
지우기 후에 상황에 따라 isScrolling이 참이 되는 현상
└> 기존에는 MemoryController::Update에서 VaildMin과 VaildMax에 따라서 isScrolling 속성을 업데이트 해주었는데 그 부분을 지우고 수직스크롤 이동을
담당하는 클래스에서 isScrolling 속성을 업데이트 해주는 방법으로 변경하였다. 따라서 다른 상황에서는 isScrolling 속성이 참이 되지 않는다.

<<○>>
상태표시줄 Encoding Format 업데이트
인코딩 포맷은
1. 처음 프로그램을 실행했을 때
2. 열기를 했을 때
3. 새로만들기를 했을 때
4. 저장(경로가 없을때)
5. 다른이름으로 저장했을 때
이 값을 textEditor가 가지고 있으며 위 이벤트 발생 시 계속 값을 업데이트 해주고 상태표시줄에도 업데이트된 인코딩값이 나타나도록 고쳐주자.

오전 9:19 2023-09-13

<<O>>
자동줄바꿈 상태 일 때 ScrollController::UpdateFileVSInfo에서 논리오류가 있었다.
└> sum을 구하는 방법은 i를 Document::end +1 로 초기화를 해서 Save 이후 이 함수가 호출 될 때 수직스크롤 최대값이 맞지 않는 오류가 있었으며
i를 Document::start + Paper::rowCount로 계산을 하여 해결하였다.

<<○>>
종이 밖을 포함한 선택영역을 지웠을 때 Document::Delete가 실행된다. 이때 디스크파일을 새로 만들게 되나, Document의 start와 end가 맞지 않은 상태가 된다.
└> 해당 함수의 마지막에 start와 end도 업데이트가 될 수 있게끔 함수를 고쳐주었습니다.

<<O>>
Delete 후 실행취소 시 문제가 없는지 확인해보자 / 줄 중간부터 선택하여 지웠을 때 해당 줄 전체가 지워져 버린다.
└> Delete디스크파일에는 지워진 내용은 잘 저장되어 있는걸로 보인다. / 어디가 문제인지 살펴보자 / 더 소량데이터로 테스트 해보며 문제 지점을 정확히 파악해보자.
현재 찾은 문제점으로는 Document::Delete에 있으며 이 함수는 종이 외부에도 선택영역이 있을 때 사용되는 함수이며, 함수 내에 종이 내의 내용만 지우는
Paper::Delete도 포함하고 있다. 하지만 선택영역이 종이밖에 있을 때 선택을 시작하는 줄이나, 선택이 끝나는 줄의 칸에 따라서도 새로운 디스크파일에 적히는
내용이 달라져야 하는데 그러한 부분이 전혀 고려되지 않고 있다. / endPosition.row번째 줄을 지우고 업데이트를 할 때 해당 내용을 이전 줄에 붙여 넣어야 한다.

<<O>> TakeIn
TakeOut이 진행 된 후 스크롤 위치 및 현재 위치 어떤식으로 변경되는지 검사해보고 TakeIn 그대로 적용하기.
영역을 지울 때는 지울영역이 종이에 다 있을 경우에는 종이에서만 내용을 지우고 MemoryController에서 TakeIn을 할 필요가 있어 보인다.
지우고 난 뒤에 수직, 수평스크롤의 포지션을 구해야하는데 어떻게 구하면 될까?
지금 상태에서는 포지션을 구하고 나서 MemoryController에서 TakeIn이 이뤄질 예정이라 포지션의 위치가 이상하다.
여기에 대한 아이디어는 SetPosition과 Notify를 하기전에 줄 수를 검사해서
MemoryController의 TakeIn을 부르는것은 어떨까 그러면 SetPosition도 Notify가 불러지기전에 제대로 할 수 있기 때문이다.
BackSpaceKey, DeleteKey, EnterKey 다 줄 수가 바뀌는 것이니 이에따른 TakeIn과 TakeOut시 변경되는 값들에 대해 검사가 필요하겠다.
below, hSMax, vSMax, disFileVSMax, vaildMin

<<△>>
Document::SetSelectingInfo 논리오류
└>선택하기 업데이트 Document::SetSelectingInfo에서 종이의 마지막이라는 조건을 사용하는데 문서의 마지막이라는 조건까지 붙어야 올바른 조건이다.
그렇게 때문에 Document::end가 Document::length가 보다 작으면 마지막이 아니기 때문에 이 조건을 고쳐주었다.
여기에서 end가 length 보다 작고, 현재 줄이 endPosition.row보다 작거나 같으면 startPoint를 current로 고치도록 되어 있는데
endPosition이 업데이트가 된 상태가 아니라 업데이트 이전의 위치이기 때문에 조금 걸리는 부분이 있는 상태이다.
또한, 함수가 오버로딩 되어 있는데 나머지 하나도 필요하다면 고쳐줘야한다.

<<△>>
메모리누수
Command중에서 실행취소나 재실행이 가능한 클래스는 UnDoReDoCommand라는 가상클래스를 만들어 상속을 받았었다.
그렇게 하니 소멸자가 불러지지 않았는데 Stack의 소멸자에서 dynamic_cast<UnDoReDoCommand*>로 처리하니 소멸자가 정상적으로 불러진다.

<<□>>
└> 메모리 누수를 잡으면 해결이 될 거라 생각했지만, 누수 해결 전 이제 더이상 나타나지 않는 오류로 미제사건.

실행취소 재실행 이후 새로운 파일을 열어서 이벤트를 취하면 
_CRT_SECURITYCRITICAL_ATTRIBUTE
void __CRTDECL operator delete(void* const block) noexcept
{
    #ifdef _DEBUG
    _free_dbg(block, _UNKNOWN_BLOCK);
    #else
    free(block);
    #endif
}

오후 4:50 2023-09-12
<해결>열기 시 수평스크롤 MAX값 이상하다.
└>SF_ALL에서 조건식 수정완료. i <= this->textEditor->document->GetLength()

<<완료>> Position 연산자 오버로딩

오전 9:31 2023-09-11
TakeIn 정의 테스트필요

오전 9:28 2023-09-08
<<완료>> PageUpKeyAction::Execute
<<완료>> PageDownKeyAction::Execute
<<완료>> ShiftPageUpKeyAction::Execute
<<완료>> ShiftPageDownKeyAction::Execute
<<완료>> 줄 이동

오전 9:31 2023-09-07
<<완료>> RowBackSpaceKeyCommand::Execute
<<완료>> RowBackSpaceKeyCommand::Unexecute
<<완료>> RowDeleteKeyCommand::Execute
<<완료>> RowDeleteKeyCommand::Unexecute

오전 9:24 2023-09-06

<<해결>>
확대 축소 시 스크롤 포지션 조정이 필요하다. / 확대 축소 시 자동줄바꿈 고려
└> TextEditor::GetBack을 호출하고 그에 따라 스크롤포지션 업데이트도 진행하여 문제없음.

<<해결>>
미리보기 창에서 인쇄버튼 누를시 다이얼로그 안뜨고, 메인윈도우에서 내용 다 사라짐.
└> Preview::OnPrintButtonClicked에서 고치고 해결

<<해결>>
빈 문서에서 자동줄바꿈 시에 뻑

<<완료>>
미리보기윈도우에 상태표시줄로 용지정보 적어야함.

<<완료>>
열기, 새로만들기 시 디스크파일 삭제하기. (FileMaker 클래스에서 Remove() 구현)

오후 2:18 2023-09-04
<<완료>> 인코딩 Builder 디자인패턴 적용해보기

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

오전 9:47 2023-09-01
선생님께서는 인코딩을 할 때 굳이 적용을 안해도 되지만, 적용하는 연습을 해보고 생성쪽 패턴인 Builder 추천
바로는 아니고 다 만들고 나서 고려해보기.

Document::Save 진행하면서 알게된 점: 디스크파일에 개행문자를 적을때 \n만 적으면 디스크파일에서 read를 할 때 \r이 추가되기 때문에 \r\n으로 적지 않아도 된다.

오전 9:31 2023-08-31
UTF-8
└> ASCII를 바로 UTF-8로 변환할 수 없어 Unicode로 변환 후 UTF-8로 변환이 필요하다. / 종이 내 파일은 변환이 잘된다.
└> 테스트 필요함 ( 종이 밖 영역이 잘 인코딩 되는지와 내가 인코딩한 파일을 열었을 때 내가 인코딩한대로 잘 열리는지 테스트해보자.)
└> 테스트 통과

UTF-8(BOM)
└> 완료

UTF-16 LE
└> 완료

UTF-16 BE
└> 완료

인코딩하여 저장해야한다.

오후 4:01 2023-08-30
열기시에 설정한 encoding으로 디코딩하기.

문제: 빈 종이 불러오기 시 뻑 발생,  140,000줄 불러오기 시 맨 마지막줄에 빈줄 생성이 안되어 있음.
└> 논리오류 처리하며 해결

오전 9:55 2023-08-24
미리보기 윈도우에서 print버튼을 클릭하여 printfDialog가 팝업된 후 X버튼을 눌러 창을 끄면 미리보기 윈도우가 꺼지지는 않으나 그 위로 기존 Notepad윈도우가 다시 나타난다.

오전 10:54 2023-08-23
문제가 발생하는 상황
<<해결>>140,000줄 파일을 열고 자동줄바꿈 후 글꼴을 12point로 바꾼 뒤 스크롤을 가장 아래로 이동하면 뻑남.
└> Paper::Wrap, Paper::UnWrap에서 현재 위치를 그대로 이동하도록 고쳐주니 뻑 나지 않음.

<<해결>>140,000줄 파일을 열고 자동줄바꿈 후 글을 쓰거나 지워 isUpdate가 거짓인 상황에서 저장하면 저장파일에 DummyRow들도 Row가 되어 저장된다.
└> Document::Save에서 문제점 그대로 고쳐 해결

ZoomIn, ZoomOut, ZoomReset를 하긴 했지만 느려서 그렇게 마음에 들지는 않는다.

MemoryController::SaveRowLength에서 시간을 더 단축할 수 있을 것으로 보인다. 가능하면 시간을 더 단축해보자.

오후 4:03 2023-08-22
ZoomIn과 ZoomOut 그리고 ZoomReset을 하는 과정에서 업데이트 여부와 수평, 수직 스크롤 처리를 어떻게 해야할지 생각해봐야 한다.
먼저 업데이트 여부가 관계가 있을까? 아직 잘 모르겠다.

ZoomIn과 ZoomOut을 하는 경우에

<<자동줄바꿈 상태이면>>
종이에 있는 내용을 자동줄바꿈 해제 했다가 다시 자동줄바꿈을 하는데 수평스크롤은 상관이 없지만
수직스크롤은 높이가 늘어나거나 줄어들수가 있다. 따라서 여기에 대해 below를 제외한 diskFileVSMax, VSMax, vaildMin 업데이트가 필요하다.
그러면 업데이트가 안된 상황이면 업데이트를 하고 UpdateDiskFileInfo를 하고 업데이트가 되어 있는 상황이면 UpdateDiskFileInfo만 하자.

<<자동줄바꿈 상태가 아니면>>
기존 longestRow에 대해서만 줄 길이를 다시 구해서 수평스크롤 업데이트가 필요하다. ZoomInCommand::Execute()내 에서 구하고 SF_NORMAL로 가자.
수직스크롤은 below를 제외한 diskFileVSMax, VSMax, vaildMin 업데이트가 필요하다.

ScrollController::UpdateDiskFileInfo를 할 때 업데이트를 하고 진행하는게 필요해보인다.
그런데 문제는 폰트를 변경했을 때 처럼 디스크파일에 저장된 줄 길이가 모두 업데이트가 되어야한다.
파일을 새로 만들어야 하는것은 아니지만, 줄길이를 다시 구해서 값을 고쳐줘야할 필요가 있는상태이다.
폰트에서 어떻게 했었는지 확인 해보자. 자동줄바꿈 상태이건 아니건 무조건 해야한다.
폰트에서 할 때는 MemoryController::SaveRowLength 함수를 사용하는데 임시파일이 생성되었다가 remove and rename되는 방식이다.
하지만 파일을 새로 만들 필요는 없을 것 같으며 덮어쓰기 형식으로 진행 할 수 있어보인다.


오후 12:00 2023-08-17
수직 스크롤 업데이트 Problem
diskFileVSMax는 (문서의 줄수 * 문자 높이) - (종이의 줄수 * 문자 높이) 로 계산이 되고 있다.

isUpdated가 참인 경우에는 MemoryController::Save없이 바로 MemoryController::MoveUp 이나 MemoryController::Down
을 하고 있는데, 이때는 ScrollController::below와 ScrollController::vailMin만 업데이트가 이뤄지고 있어서
diskFileVSMax의 값이 맞지 않은 상황이 생긴다.
어떤 상황에서 이 값이 달라지는지 경우의 수를 생각해보고 그에 맞게 방법을 생각해보자.

1. isUpdated가 참인 상황에서 MoveUp 또는 MoveDown이 호출 되는 상황
자동줄바꿈이 아닌 상태에서 종이에서 지운 줄 수 만큼 추가가 되면 문제가 없지만, 종이에서 지운 줄 수와 종이에 다시 추가된 줄수가 다르다면 이 값은 잘못된 값이다.
자동줄바꿈 상태에서 종이에서 지운 줄 수 만큼 추가가 되면 문제가 없지만, 마찬가지로 종이에서 지운 줄 수와 종이에 다시 추가된 줄수가 다르다면 이 값은 잘못된 값이다.

이 값을 새로 구하는방법은 자동줄바꿈이 아닌 상태라면 매우 간단하다. (문서의 줄수 - 종이의 줄수) * 문자 높이
자동줄바꿈 상태라면 추가나 삭제되는 줄수가 종이의 RowCount보다 작다면 삭제되고 추가되는 줄 수를 세어서 가감해주는 방법이 있을것이고,이동되는 양이 종이의 RowCount보다 큰 경우라면 VaildMin과 below를 구하는건 어차피 하는 일이니 거기에 추가적으로 below + 종이의 줄 밖의 문자 줄수를 세고 문자 높이를 구해서 구할 수가 있게된다.
이미 업데이트가 되어있는 상황에서라면 vSMax는 구해져 있지 않나? 아 어떤 처리를 하게 되면 vSMax가 바뀔수 있고 그 값을 diskFIleVSMax로 구하려고 하는거구나. 그러면 처음에 생각한데로 below와 validMin의 구해져 있는 상태에서 종이 밖의 줄 수를 다시 새서 문자높이를 구하는 방법을 써야한다는건데 자동줄바꿈 상태에서 이게 시간이 오래걸릴것 같다. 

isWrapped가 거짓이면 diskFileVSMax = (문서의 줄 수 - 종이의 줄 수) * 문자 높이
isWrapped가 참이면 diskFileVSMax = vSMax - (종이의 줄수 * 높이)

MoveUp과 MoveDown시 diskFileVSMax값이 업데이트가 되도록 고쳐서 해결.

오후 12:48 2023-08-14
바꾸기

오후 8:33 2023-08-12

<<완료>> CharacterBackSpaceKeyCommand::Execute
<<완료>> CharacterBackSpaceKeyCommand::Unexecute
<<완료>> CharacterDeleteKeyCommand::Execute
<<완료>> CharacterDeleteKeyCommand::Unexecute
<<미완료>> RowBackSpaceKeyCommand::Execute
<<미완료>> RowBackSpaceKeyCommand::Unexecute
<<미완료>> RowDeleteKeyCommand::Execute
<<미완료>> RowDeleteKeyCommand::Unexecute

*테스트진행 환경
Execute
isNew가 참인 경우
- isScrolling이 참일 때
- isWrapped가 참일 때

isNew가 거짓인 경우
- isSelecting가 참일 때
- 시작할 위치가 종이밖에 있을 때
- isWrapped가 참일 때

Unexecute

오전 9:28 2023-08-10

- 찾기

<<완료>> void Paper::FindNext(char* findWhat, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Paper::FindNextMatchWholeWord(char* findWhat, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Paper::FindNextMatchCase(char* findWhat, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Paper::FindNextMatchWholeWordAndCase(char* findWhat, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Paper::FindPrevious(char* findWhat, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Paper::FindPreviousMatchWholeWord(char* findWhat, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Paper::FindPreviousMatchCase(char* findWhat, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Paper::FindPreviousMatchWholeWordAndCase(char* findWhat, bool* found, Long* row, Long* start, Long* end);

<<완료>> void Document::FindNext(char* findWhat, Long startLine, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Document::FindNextMatchWholeWord(char* findWhat, Long startLine, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Document::FindNextMatchCase(char* findWhat, Long startLine, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Document::FindNextMatchWholeWordAndCase(char* findWhat, Long startLine, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Document::FindPrevious(char* findWhat, Long startLine, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Document::FindPreviousMatchWholeWord(char* findWhat, Long startLine, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Document::FindPreviousMatchCase(char* findWhat, Long startLine, bool* found, Long* row, Long* start, Long* end);
<<완료>> void Document::FindPreviousMatchWholeWordAndCase(char* findWhat, Long startLine, bool* found, Long* row, Long* start, Long* end);

-바꾸기


오전 10:34 2023-08-09
Glyph 생성 시 메모리맵 생각해보고 무거우면 가볍게 만들기. (안쓰는 함수 삭제 등)


오전 10:34 2023-08-08
프로그램 내에서 지켜야 할 규칙
scrollFlags가 SF_NORMAL인 상황이더라도 longestRow 이전의 줄 수가 바뀌는 상황이면 longestRow값 수정 필요
Document::Delete는 업데이트가 이뤄져 있는 상황을 가정하에 실행된다. (메세지 박스를 추가해두자.)

오전 9:26 2023-08-07
오늘 할 일
<<완료>> DeleteCommand 자동줄바꿈 상태에서 테스트
<<완료>> PasteCommand 실행취소 시 상황에 따라 Delete 해주기.
<<완료>> DeleteCommand::Unexecute // scrollFlags부터
- TakeIn

문제: 줄을 지우고 스크롤을 막 이동하면 TextOutVisitor에서 뻑이난다. / start에서 음수가 들어가기 때문인데 원인을 더 찾아봐야한다.


오전 11:02 2023-08-04
SF_NORMAL인 상황이라도 longestRow 이전에 있는 줄 수가 변동된다면 longestRow값은 변경이 필요한 상황이다.
사용중에 상태표시줄에서 볼 수 있도록 전체줄수와 수직스크롤 MAXIMUM, 수평스크롤 MAXIMUM이 나타나면 좋을 것 같다.

오전 10:23 2023-08-03
Unexecute가 있는 Command들을 정리하고 실행취소와 재실행을 위해 어떤 값들이 사용되는지 확인해놓자.
그렇게 되면 UnDoReDoCommand의 속성을 정리할 수 있게된다.

붙여넣기의 실행취소에서 현재 Paper::Delete만 사용하고 있는데 상황에 따라 Document::Delete를 사용해야한다. 아직 Document::Delete를 구현하지 않아 적용하지는 못한 상태이다.

<<확인 완료>>Document::Move 함수가 자동줄바꿈 상태일 때 제대로 되지 않을것 같아서 일단 사용하는 곳의 위치를 모두 확인하였다.
제대로 되지 않을것 같은 이유는 자동줄바꿈 상태 때문이다. 이 상태에서는 below를 사용해야 할 것 같다. 나중에 한번 확인해보자.
확인결과: Move나 GetPosition은 모두 자동줄바꿈이 아닌상태의 Row 줄 수를 기준으로 나타내기 때문에 문제가 없다.


오후 3:22 2023-08-02
1. 영역을 지울 때는 지울영역이 종이에 다 있을 경우에는 종이에서만 내용을 지우고 MemoryController에서 TakeIn을 할 필요가 있어 보인다.

2. 지울 영역이 종이 밖에도 있을 경우에는 디스크파일에서 처리를 하고 업데이트가 필요한 값이 있으면 업데이트를 해주는것이 어떨까 싶다.
   └> 왜냐하면, 지울 줄들을 다 메모리에 Glyph로 생성하여 올리고 지우는일이 속도면에서 시간을 많이 소비할 것으로 보이기 때문이다.
   └> 그렇다면, 디스크파일과 메모리에서 각각 선택영역을 지웠다면 어떤 값들이 업데이트가 되야할 지 생각해보자. 이 부분을 생각한다면 좀 더 길이 보이기 시작할 것 같다.

* 종이 밖에서 삭제가 일어났을 때
- 지울 영역이 한 줄 미만이라면, 업데이트 후 해당 줄로 MoveUp Or MoveDown을 한다.

- 지울 영역이 한 줄 이상이라면, 어떤 값들이 업데이트가 필요할까?
1. Document::AddDeletedContents(Position start, Position end, Long* startPointer, Long* endPointer) 실행
2. 디스크파일은 새로 만들어야한다.
   └> 지울 영역전까지 옮겨쓰고, 지울 영역 다음부터 옮겨적는다.
   └> 이 작업이 AddDeletedContents함수와 겹치는 줄이 없기 때문에 두 함수는 각각 만들어서 사용하면 될 것 같다.
   └> 이 함수의 이름은 Document::Delete로 정하자.
   └> 처리과정을 작성해보자.
      └>1. Document::AddDeletedContents로 지울 내용을 텍스트파일에 옮겨 쓴다.
      └>2. 지울 영역에 따라 Paper::Delete 또는 Document::Delete를 호출한다.
      └>3. Document::Delete가 일어난 경우 isUpdate는 TRUE가 되도록 하고, UpdateDiskVSInfo를 같이 호출한다.
      └>4. 이동해야 할 위치는 document.startPosition.row 번째 줄, document.endPosition.column 번째 칸으로 이동해야한다.
      └>5. 필요에 따라 MoveUp 또는 MoveDown 후 TakeIn까지 필요한 상황이다.

      └>6. 이제 여기에 맞게 below, hSMax, vSMax, disFileVSMax, vaildMin 등의 값이 정해져야한다.
      └>7. 수평스크롤 최대값은 지울영역 줄 중에 longestRow가 있으면 SF_ALL.
      └>8. 


지우고 난 뒤에 수직, 수평스크롤의 포지션을 구해야하는데 어떻게 구하면 될까? / 지금 상태에서는 포지션을 구하고 나서 MemoryController에서 TakeIn이 이뤄질 예정이라
포지션의 위치가 이상하다.
그러면 TakeOut이 진행 된 후 스크롤 위치도 한번 검사해볼 필요가 있다.
여기에 대한 아이디어는 SetPosition과 Notify를 하기전에 줄 수를 검사해서 MemoryController의 TakeIn을 부르는것은 어떨까 그러면 SetPosition도 Notify가 불러지기전에
제대로 할 수 있기 때문이다.

BackSpaceKey, DeleteKey, EnterKey 다 줄 수가 바뀌는 것이니 이에따른 TakeIn과 TakeOut시 변경되는 값들에 대해 검사가 필요하겠다.
below, hSMax, vSMax, diskFileVSMax, vaildMin
- 

오전 9:12 2023-08-01

오늘 할 일과 앞으로 할 일들을 정리해보자

- 선택영역 지우기
  └> 현재 지울 영역이 종이 내에 있을때 처리를 문제가 없다. / 하지만 지울 영역이 종이 외부에도 있을 때 어떻게 처리할지 고민하고 처리할 숙제이다.
  └> 또한, 줄을 많이 지웠을 때 TakeIn함수가 필요할 것으로 예상된다.

<<해결>>
- 자동줄바꿈 상태일 때 불여넣기 및 실행취소 테스트
  └> Paper::WrapRow(Long index, Long width, CharacterMetrics* characterMetrics, bool move) 의 매개변수에서 index는 0 base로 값을 넣어야 하는데 1 base로 넣어서 문제가 발생했다.

<<해결>>
- 140,000줄 문서를 불러오고 맨 마지막으로 이동하여 문자를 적고 맨처음으로 갔다가 다시 마지막으로 와서 문자를 적을때 캐럿위치가 이상하게 적힌다.
  └> 원인은 GetBack후에서 isScrolling 속성이 계속 참으로 유지가 되어 GetBack이 계속 발생 하였고,
      TextEditor::GetBack() 함수에서 this->isScrolling 상태를 변경해주는 코드를 한 줄 추가하였다.

<<해결>>
- 자동줄바꿈 상태에서 문서를 수정한 뒤 다른 파일을 열기시에 캐럿위치가 이상하다.
  └> 자동줄바꿈 후 current를 첫번째 줄로 이동하고 줄에서도 현재위치를 처음으로 이동하여 해결하였습니다.

Use Case Modeling
01. 글자를 붙여쓰다.
02. 문서를 보관하다.
03. 문서를 열다.
04. 글꼴을 바꾸다.
05. 적을 위치를 이동하다.
06. 한 글자를 지우다.
07. 글자를 끼워쓰다.
08. 종이를 옮기다.
09. 종이 크기를 조정하다.
10. 줄을 자동으로 바꾸다.
11. 글자를 선택하다.
12. 글자를 복사하다.
13. 글자를 붙여넣다.
14. 글자를 잘라내다.
15. 글자를 찾다.
16. 글자를 바꾸다.
17. 실행을 취소하다.
18. 문서를 확대/ 축소하다.
19. 문서를 미리보다.
20. 문서를 인쇄하다.
21. 상태표시줄을 만들다.
<<완료>>22. 도움말을 만들다.

0. 형상관리, 주석, 프레임워크 그리기
1. PageUpKeyAction, PageDownKeyAction, ShiftPageUpKeyAction, ShiftPageDownKeyAction 구현 및 테스트.
2. SelectedTextOutVisitor
  ㄴ 선택영역이지만 메모리에 없는 경우 줄 선택에 대한 표시가 나타나지 않는다.
  ㄴ void SelectedTextOutVisitor::Visit(Paper* paper) { 오버플로우인 경우 있다. 줄 선택상태이면 표시하는 if 문에서 오버플로우
  ㄴ 한 줄만 입력후에 왼쪽방향으로 선택하기 시도해보면 위에 적어놓은 문제를 확인 할 수 있다.
  ㄴ Visitor가 2개 이기 때문에 첫번째 Visitor에서 가로 상에 몇번째부터 출력하면 될지 구하기 때문에 미리 저장해두면 두번째에서 또 안해도 되기 때문에 생각해보자.
  ㄴ 출력을 시작할 줄과 출력을 끝낼 줄이 Row단위로 선택 시작줄과 선택이 끝나는 줄 사이이면 SelectedTextOutVisitor를 생성하고 호출하자.

3. 한글 입력시 세로 스크롤이 생길 때 세로스크롤포지션 업데이트가 제대로 안되는것으로 보임.
4. DummyRow에서 줄 전체를 선택 후 Delete키로 지우면 이전 줄 마지막으로 이동되며, 실행취소하면 다시 DummyRow가 선택ㅇㅇ 상태로 생성되고 이때 Delete키를 누르면 선택상태가 아닌것처럼 Delete키가 먹힘.
5. 세로스크롤이 생기면서 클라이언트 크기가 변경되는것 같고 거기에 따라 자동줄바꿈이 다시 일어나니 글자 줄들이 바뀌네요. 여유값을 재조정 해줄 필요가 보임.현상이 약간 바뀌네. 확인 필요
6. 마우스 관련 이벤트 모두 점검 필요. 메모리 관리버전 이후로 확인하지않음. shift + 왼쪽클릭 / 마우스 휠 미끄럼틀처럼 만들어보기
7. 바꾸기 시에 찾기 옵션도 적용되어야 한다. 지금 적용 안되어 있음(대소문자 구분, 단어단위로)
8. 확대 축소 시 스크롤 포지션 조정이 필요하다. / 확대 축소 시 자동줄바꿈 고려
9. SetPosition할 때도 조건을 주어 필요한 상황에서만 할 수 있도록 / 스크롤컨트롤러 클래스에서 Update와 SetPosition 알고리듬 수정 / 스크롤 세부조정
10. Delete 관련해서 OnSize가 너무 많이 일어나고 있는것 같아 확인 필요.
11. 닫기버튼 눌렀을 때 메세지박스
12. F5 시간 나타나는 기능 추가하기.
13. 자동줄바꿈 첫 실행 시 스크롤이 붙으면 여러번 실행이 될 수 있다. 이런경우 미리 차단 하여 실행횟수를 줄일수 있으니 차 후 생각해보자.
빈 문서에서 자동줄바꿈 시에 뻑

SF_COMEPARE이 한 줄에 대해서만 변동이 있을 때 쓰는 플래그 인데 이 줄이 만약 longestRow이면서 
더 짧아진다면 전체 줄에서 다시 longestRow를 찾아야 하는 상황으로 보인다. 하지만 현재 그렇게 구현되어 있지 않음.
먼저 더 짧아진다면 전체 줄 에서 다시 longestRow를 찾는 방법으로 고치긴 했으나, 한글을 입력할 떄 또는 지울때 너무 느리다.
개선책은 두번째로 가장긴줄도 구해 놓는것은 어떠한가 나중에 필요시 더 자세히 연구해보자

미리보기 창에서 인쇄버튼 누를시 다이얼로그 안뜨고, 메인윈도우에서 내용 다 사라짐.
미리보기윈도우에 상태표시줄로 용지정보 적어야함.
선택상태에서 ↓방향키 눌렀을 때 캐럿위치 이상하다.
찾기 할 때 찾을내용의 문자가 ASCII인지 아닌지 미리 구해서 배열에저장을 해놓고 하면 수를 줄 일 수 있지 않을까? 자동줄바꿈 상태에서

줄 길이가 줄 너비가 보다 작다면 자동줄바꿈이 필요가 없다.
자동줄바꿈함수에서 조건식을 추가하여 실행횟수를 줄일 수 있을것으로 보인다.

글꼴을 변경할 때 isScrolling이 참이 되는 현상

OnSize시에 수직으로 클라이언트 크기가 변동될 때 스크롤 위치에 대해서 생각해보자
또한 수평스크롤을 이동할 때에도 마찬가지로 현재 생각한데로 해놓긴 했지만, 시간이 나면 한번 더 살펴보는것도 좋을것 같다.

자동줄바꿈 실행 후 맨 처음 한번 아스키코드 입력이 안되고 다시 원상복구 된다.

실행취소 재실행 이후 새로운 파일을 열어서 이벤트를 취하면 
_CRT_SECURITYCRITICAL_ATTRIBUTE
void __CRTDECL operator delete(void* const block) noexcept
{
    #ifdef _DEBUG
    _free_dbg(block, _UNKNOWN_BLOCK);
    #else
    free(block);
    #endif
}

오류발생

열기, 새로만들기 시 디스크파일 삭제하기.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


오전 9:27 2023-07-31
<<해결>>
dd
dd

위와 같이 적고 3번째 줄이에서 shift+↑로 첫번째 줄 까지 선택하면 선택하기 시 잘못됨.
Document::Select에서 사용되는 this->end가 업데이트 전의 값으로 사용되어 오류가 있었음. 이 값을 this->start + this->paper->GetRowCount()로 변경.

오늘할일

먼저 디스크파일에 개행문자를 저장할 때 '\n'으로 저장을 했었는데 "\r\n"으로 고칠 필요가 있다.
어떤 클래스와 함수에서 이런방식으로 저장하고 있는지 찾고 그로인해 발생하는 문제는 없는지 살펴보자.
이게 다 처리되면 붙여넣기가 잘 되는지, 열기, 불러오기, Document::LoadToMemory, Document::LoadToFile 등 문제가 없는지 꼼꼼히 살펴보자.

'\n'이 사용된 곳
void Document::LoadToFile(string pathName, CharacterMetrics* characterMetrics)
void Document::Load(string pathName, CharacterMetrics* characterMetrics)

2. void CopyCommand::Execute() 
└> Copy할 내용중에 개행문자가 있는 경우 \n만 개행문자로 표현이 되었으나, \r\n으로 변경하였습니다.
3. void Paper::Paste(char* text, CharacterMetrics* characterMetrics)
└> paste.txt 파일로 부터 읽은 텍스트에 개행문자가 \r\n 형태로 저장되어 있으며, 텍스트를 한 문자씩 읽었을 때 '\r'이면 다음 문자 까지 읽어서 "\r\n"으로 Row를 생성하도록 고쳤습니다.

void Document::PasteFromFile(Long start, Long end, CharacterMetrics* characterMetrics, bool isWrapped, Long width) 
└> 재실행을 했을 때 사용하는 함수로써 실행취소를 먼저 성공적으로 처리를 해야한다.

'fgets'가 사용된 곳
void Document::LoadToFile(string pathName, CharacterMetrics* characterMetrics)
void Document::Load(string pathName, CharacterMetrics* characterMetrics)
void Document::PasteFromFile(Long start, Long end, CharacterMetrics* characterMetrics, bool isWrapped, Long width) 
void MemoryController::Save() 
void MemoryController::SaveRowLength()

'fread'가 사용된 곳
void Document::LoadToMemory(Long start, Long end, CharacterMetrics* characterMetrics)
void Document::LoadToMemory(bool appendFromFront, Long start, Long end, CharacterMetrics* characterMetrics) 
void Document::Save(string pathName)
void Document::CountRows(Long* line, Long count, Long rectRight, CharacterMetrics* characterMetrics, Long* total) 
void Document::CountRows(bool reverse, Long* line, Long count, Long rectRight, CharacterMetrics* characterMetrics, Long* total) 
void Document::Copy(Long row, FILE* file, char* contents, Long* length)
void ScrollController::UpdateFileVSInfo() 
Long ScrollController::UpdateVaildMin()


그 후 붙여넣기 실행취소를 실행해보자.


오후 4:51 2023-07-29
\r\n 줄 복사시 이렇게 된다는걸 알아야 하는구나.

오전 10:30 2023-07-27
줄 길이가 줄 너비가 보다 작다면 자동줄바꿈이 필요가 없다.
자동줄바꿈함수에서 조건식을 추가하여 실행횟수를 줄일 수 있을것으로 보인다.

오후 3:11 2023-07-26
글꼴을 변경할 때 isScrolling이 참이 되는 현상

오전 11:04 2023-07-25
OnSize시에 수직으로 클라이언트 크기가 변동될 때 스크롤 위치에 대해서 생각해보자
또한 수평스크롤을 이동할 때에도 마찬가지로 현재 생각한데로 해놓긴 했지만, 시간이 나면 한번 더 살펴보는것도 좋을것 같다.

오후 3:09 2023-07-20
자동줄바꿈 실행 후 맨 처음 한번 아스키코드 입력이 안되고 다시 원상복구 된다.

실행취소 재실행 이후 새로운 파일을 열어서 이벤트를 취하면 
_CRT_SECURITYCRITICAL_ATTRIBUTE
void __CRTDECL operator delete(void* const block) noexcept
{
    #ifdef _DEBUG
    _free_dbg(block, _UNKNOWN_BLOCK);
    #else
    free(block);
    #endif
}

오류발생

오전 9:23 2023-07-19
MemoryController::Update는 ScrollController::SetPosition 이후 진행 되어야한다.
ScrollController::SetPosition은 ScrollController::Update 이후 진행 되어야 한다.

이런 순서로 호출이 이뤄져야한다.
ScrollController::Update → ScrollController::SetPosition -> MemoryController::Update

이유는
ScrollController의 VerticalScroll의 Maximum이 정해진 다음에 거기에 따라 Position을 옮길 수 있고 Position을 옮긴 다음 거기에 따라 메모리에 적재될 데이터가 정해진다.

그러면 ScrollController에서 Maximum을 구하는걸 빼서 진행하는건 어떨까?
그렇게 되면 SetMaximum->SetPosition->Notify순서로 이뤄진다.


ScrollController::SetPosition을 항상 Notify전에 실행하였는데
스크롤의 Maximum값이 업데이트 되기 전의 값을 기준으로 Position을 구하다 보니 오류가 발생한다.
Notify 이후에 SetPosition을 하는 순서로 변경해보자.

이렇게 되면 MemoryController에서 Position에 따라서 업데이트가 진행이 될 때도 있어서 Position이 업데이트가 안된 상태
이면 업데이트가 제대로 이뤄지지 않는다.

오전 9:47 2023-07-17
<완료>SelectingRightKeyAction / 이후 선택상태이면 unselect하는 부분 모두 고쳐주기.
<완료>그냥 화면내에 있을때
<완료>스크롤링 이후 화면밖에 있을 때
<완료>스크롤링 이후 화면내에 있을 때

오전 9:50 2023-07-14
실행취소나 재실행 후 새로운 파일을 로드하고 다른 이벤트를 진행하였을 때 뻑이 나는 현상 / MemoryController의 Save 함수를 고쳐서 해결
또한 Paper에서 안쓰는 함수 주석처리 필요.
<완료> 선택해제 Document::UnSelect 구현 후 UnSelect하는 함수 다 고치고, isUpdate 상태 다 고치자.

오전 9:50 2023-07-13
<완료>OnCharCommand :: Execute, Unexecute
<완료>OnCharEnterCommand :: Execute, Unexecute
<완료>OnImeComposition :: Execute, Unexecute
<완료>OnImeCharCommand :: Execute, Unexecute`

오전 9:30 2023-07-12
상위로 이관 되었습니다.

오전 10:20 2023-07-11
목표: 자동줄바꿈 상태에서 스크롤링하고 GetBack하는 함수와
디스크파일에서 선택된 영역을 Load할 때 불러지는 함수가 자동줄바꿈 상태와 아닐 때 제대로 작동 하는지 테스트

테스트를 진행해볼 상황을 세세히 정하고 각각 테스트 진행해보자
전제조건: 자동줄바꿈OFF

1. 한 줄만 선택하고 스크롤링 후 다시 돌아오기. ★
2. 한 줄이상 선택하고 스크롤링 후 다시 돌아오기. ★
3. 선택상태에서 스크롤링 후 돌아오지 않고 선택하기 실행 시 ★
4. 한 줄 선택상태에서 스크롤링 후 돌아오지 않고 다음 줄 선택하면 일부분 지워지는 현상 ★
5. 선택하면서 MoveDown될 때 <<다른 문제를 해결해서 자연스레 해결이 된 것 같으며, 현재는 동일 증상 나타나지 않음>>

오전 10:12 2023-07-07
selectedTextOutVisitor에서 화면의 마지막줄이 document의 end일때 그 다음줄이 선택상태이면 화면에 보이는
마지막 줄 끝에 선택표시를 해줘야한다.

PageUpKey, PageDownKey가 구현이 필요하다.


오전 10:42 2023-07-05
Row::SelectContents(), Row::SelectContents(Long start, Long end), Document::Select, Document::UpdateSelectingInfo()
순서로 정의가 필요하고 그 후 SelectedTextOut 고쳐서 제대로 실행이 되는지 확인해보자.
textOutVisitor 수평스크롤값

OnPaint에서 출력을 시작할 줄과 출력을 끝낼 줄을 다 구하고, visitor의 생성자에 매개변수로 입력하자.
이게 더 효율적인 이유는 visitor가 2개 이니 두번 계산할 것을 한번만 계산할 수 있기도 하고, 2번째 selectedVisotor를
호출 할지 안할지도 결정할 수 있다.

출력을 시작할 줄과 출력을 끝낼 줄이 Row단위로 선택 시작줄과 선택이 끝나는 줄 사이이면
SelectedTextOutVisitor를 생성하고 호출하자.

end가 paper->GetLength() 랑 똑같고, document의 end가 document의 length보다 작으면
document의 end + 1이 document.startPosition.GetRow()보다 크고 document.endPosition.GetRow()보다 작거나 같으면
색칠.

visitor가 2개 이기 때문에 첫번째꺼에서 가로 상에 몇번째부터 출력하면 될지 첫번째 비지터에서 구하기 때문에 미리 저장해두면
두번째에서 또 안해도 되기 때문에 생각해보자.

textEditor::SetCurrent가 맞지 않은지 확인


오후 3:39 2023-06-28
자동줄바꿈 첫 실행 시 스크롤이 붙으면 여러번 실행이 될 수 있다.
이런경우 미리 차단 하여 실행횟수를 줄일수 있으니 차 후 생각해보자.

오전 10:39 2023-06-21
빈 문서에서 자동줄바꿈 시에 뻑

오전 10:06 2023-06-20
Document 클래스에 있는 LoadToMemory를 MemoryController로 옮길수 있는지 확인하여 가능하면 옮겨보자

오전 10:22 2023-06-19
TakeOut, MoveDown,MoveUp, ScrollUp, ScrollDown이 자동줄바꿈 상태에서도 문제 없는지 확인해보자


오전 11:54 2023-06-15
자동줄바꿈을 할 떄에 디스크파일에서 데이터를 읽어온 다음 자동줄바꿈을 하는데
애초에 읽으면서 자동줄바꿈을 하면 더 시간을 단축할 수 있을것으로 보인다.

수직스크롤 MAX길이 계산 때문에 너무 느려졌다. 필요한 상황에서만 구할 수 있도록 생각해보자.


#이벤트 시작 시 고려해야할 상황
1. 자동줄바꿈 상태인지( 자동줄바꿈 상태이나 아니나 되도록 두개 다 한 함수내에서 처리할 수 있도록 해보자)
2. 선택상태인지
3. 메모리 업데이트가 되었는지.
4. 스크롤링 상태인지.


오후 2:22 2023-06-08
MemoryController에서 Give함수를 구현중인데 start의 위치에 따라 기존 파일에 이어서 덮어쓸 수 가 있고, 아니면 새로운 파일을 만든다음 원본파일 교체를 할 수 있을것으로 보인다.
추후 필요하다면 함수를 하나더 만들어서 효율성을 증대시켜보자


오전 9:43 2023-06-07

※ 언제 업데이트를 진행할 것인가

먼저 데이터를 작성하다가 200줄이 넘어 간다면 업데이트가 진행되는걸로 하자.

이때, 몇 줄을 디스크파일로 옮겨둘 것인가.
100줄을 디스크파일로 옮기고 100줄만 디스크파일에 남겨 놓는다면 어떻게 될까.

- 마지막에서 줄을 추가하는 경우
1. 디스크파일이 없다면
  1.1. 디스크파일을 열다
  1.2. 100번 반복하다.
    1.2.1. 유효한 데이터범위, 줄 길이를 쓰다.
    1.2.2. 줄 내용을 쓰다.
  1.3. 디스크파일을 닫다.

2. 디스크파일이 있다면
  2.1. 디스크파일을 열다.
  2.2. 파일포인터를 찾다.
  2.3. 파일포인터 이후 데이터들을 temp디스크파일에 저장해두다.
  2.4. 100번 반복하다.
    2.4.1. 유효한 데이버범위, 줄 길이를 쓰다.
    2.4.2. 줄 내용을 쓰다.
  2.5. 파일의 끝이아닌 동안 반복하다
    2.5.1. temp에서 한 줄을 읽다.
    2.5.2. file에 이어쓰다.

100,000줄이 입력 되어 있는 상태에서
250줄의 데이터가 클립보드에 복사된 상태이고, 30번째 줄에서 붙여넣기를 하면
메모리에는 100개의 줄이 저장되어 있고, 
31번째 줄 버터 100,000째 줄까지는 temp파일에 복사가 되었다가 다시 diskfile에 붙여넣어지는데 이 때 시간소요가 많이 되긴한다.

//업데이트가 진행될 때 생성되는 디스크파일에는 첫째 줄에는 유효한 데이터범위와 줄 길이를 적다.

※ 메모리 내 데이터를 디스크파일과 교환을 해야하는 경우들
1. 마지막에서 줄을 추가하는 경우
2. 마지막에서 줄을 지우는 경우
3. 중간에서 줄을 끼우는 경우
4. 중간에서 줄을 지우는 경우
5. 방향키, Home, End
6. 스크롤 이동

※ 모든데이터를 디스크파일에 저장할것인가 VS 메모리내 저장된 부분은 디스크파일에 저장하지 않을 것인가
모든데이터를 디스크파일에 가지고 있을 때와 디스크파일와 메모리에 가지고 있는 데이터를 겹치지 않게 할 때 어떤 차이가 있는가.
줄의 삽입/삭제가 없는 경우에는 덮어쓰기로 간단하게 처리가 가능하다. (스크롤 이동 등)

모든데이터를 디스크파일에 가지고 있을 때는
줄이 추가나 삭제가 되는게 아닌 이상 적을 위치를 이동할 때 파일을 두개로 만들면서 필요없는 작업을 줄여 시간을 단축 시킬 수 있다.
메모리상에서 없어지는 줄을 기존 디스크파일에 덮어쓰면 되기 때문인데 덮어쓸 파일포인터를 찾는것은 쉬운가? 모든 줄의 길이가 동일하니 몇번 째 줄인지만 알면 쉽게 구할 수 있다.

앞 쪽에서 줄 추가가 이뤄졌을 때는 오랜시간이 걸리지만 뒤쪽에서 줄 추가를 하면 그 뒤부터만 미뤄주면 되므로, 상황에 따라 걸리는 시간이 다르다.
캐럿을 이동할 때 매번 디스크파일을 새로 안만들어도 된다.

앞쪽은 그대로 쓰면서 뒤쪽만 temp로 적어놓고 추가 후 temp를 다시 file 로 옮겨적는다.
이 작업은 앞쪽에서 줄 추가를 하면 오래걸리고 뒤쪽에서 추가하면 시간이 적게걸린다.

디스크파일을 하나로 처리를 하는것을 기본으로 하고 상황에 따라서만 두 개를 만들어 바꿔주는 식으로 하자.
ex) 중간에 줄이 추가될 때나 지워졌을 때.

모든데이터를 디스크파일에 저장하는 방법으로 다시 시작해보자.
메모리내 보유량(화면내 데이터)
각각의 이벤트마다 메모리와 디스크파일 데이터 교환을 하고, 업데이트시에는 스크롤의 이동에 따라 처리를 해보자.
줄을 삽입 하거나 지울 때마다 메모리를 업데이트 하니, 딜레이가 발생한다.
그래서 어느정도의 양은 메모리쪽에서만 수정을 하다가 때가 되면 업데이트를 해주는게 좋을 것 같은데..

그럼 입력을 쭈욱 하다가 200줄이 만약 넘었으면, 앞에 100줄을 디스크파일에 넣다.
그리고 다시 메모리에서 작업을 하다.



※ 메모리 관리를 어떻게 할 것인가
메모리와 디스크 파일 사이에 잦은 업데이트를 하지 않기 위해 전 보다는 좀 더 많이 메모리에 데이터를 가지고 있어야 할 것으로 보인다.
한 줄에 1,000자가 작성된다고 가정할 때 200줄이 적당해보인다. 메모리에서 약 25MB를 차지한다.


오후 9:03 2023-06-05
r로 열으면 있는 파일이 열리는데 w로 열으면 파일이 덮어써짐.

fputs나 fgets로 한줄씩 하지말고
fread나 fwrite로 대량으로 읽어서 붙이면 시간이 줄어들지 않을까? : 시간은 줄어들지 않더라...

추상적으로 생각 해보았을 때 한 줄에 1000자를 작성할 수 있으니, 나머지칸을 빈칸으로 가득 채워서 저장을 할까 그러면 덮어쓰기가 가능하니까 그리고 대신 어디까지가 유효한 데이터 인지 저장을 같이 해두면 어떨까
줄이 지워졌을 때 업데이트가 진행되면 새로 파일교체를 할까
memcpy 도 필요시 사용하고....

오후 4:24 2023-06-04
paper의 Load 반환형을 Long으로 바꾸어 몇개가 로드 되었는지 알 수있도록하고
반환된 정수를 가지고 document의  length를 opencommand에서 구하자.
document->textEditor->paper->순 이기 때문에  paper의 매개변수에 document를 주는건 이상하다.

오후 3:57 2023-05-26
Notepad20230526 (메모리 개선 시작2) 파일부터 줄에 속성으로 줄길이를 추가하고 디스크파일에 줄을 저장하는 형태로 작업을 시작한 날이며,
문제가 있을 때 이 전 파일로 되돌아 가면된다.
paper::save에서 자동줄바꿈해제를 하는데 상황에 따라 해야한다. 수정필요

paper:: save, unwrap

오후 4:13 2023-05-24
지금 메모리 효율을 높이기 위해 주기억장치와 보조기억장치를 왔다갔다 하며
데이터 관리를 해야 할 것으로 결론을 내렸으며, 여기에 따라 많은 로직이 다시 변경
이 되야한다. 여러가지를 다 생각해서 할 수 없으니 유즈케이스 모델링을 해놓은 순서대로 차근차근 형상관리를 하면서 진행해보려고한다.


오전 10:12 2023-05-22
SF_COMEPARE이 한 줄에 대해서만 변동이 있을 때 쓰는 플래그 인데 이 줄이 만약 longestRow이면서 
더 짧아진다면 전체 줄에서 다시 longestRow를 찾아야 하는 상황으로 보인다. 하지만 현재 그렇게 구현되어 있지 않음.
먼저 더 짧아진다면 전체 줄 에서 다시 longestRow를 찾는 방법으로 고치긴 했으나, 한글을 입력할 떄 또는 지울때 너무 느리다.
개선책은 두번째로 가장긴줄도 구해 놓는것은 어떠한가 나중에 필요시 더 자세히 연구해보자

F5 시간 나타나는 기능 추가하기.
미리보기 창에서 인쇄버튼 누를시 다이얼로그 안뜨고, 메인윈도우에서 내용 다 사라짐.
미리보기윈도우에 상태표시줄로 용지정보 적어야함.

선택상태에서 ↓방향키 눌렀을 때 캐럿위치 이상하다.

찾기 할 때 찾을내용의 문자가 ASCII인지 아닌지 미리 구해서 배열에저장을 해놓고 하면 수를 줄 일 수 있지 않을까?
자동줄바꿈 상태에서

ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅇㅇㅇ}
첫번째줄 맨 앞에서 맨 뒤로 줄 선택 후 Backspace키로 지우고 되돌리기 했을 때 오른쪽 이동버튼 눌러도 선택해제 안됨.


한글 입력시 세로 스크롤이 생길 때 세로스크롤포지션 업데이트가 제대로 안되는것으로 보임.
Shift 좌우 방향키 누를 시 자동줄바꿈 상태이면 마지막줄이 아니고 마지막칸일 때 다음줄 처음으로 이동하다.
DummyRow에서 줄 전체를 선택 후 Delete키로 지우면 이전 줄 마지막으로 이동되며, 실행취소하면 다시 DummyRow가 선택ㅇㅇ 상태로 생성되고 이때 Delete키를 누르면 선택상태가 아닌것처럼 Delete키가 먹힘.
세로스크롤이 생기면서 클라이언트 크기가 변경되는것 같고 거기에 따라 자동줄바꿈이 다시 일어나니
글자 줄들이 바뀌네요. 여유값을 재조정 해줄 필요가 보임.현상이 약간 바뀌네. ㅇㅋㅇㅋ
마우스 shift + 왼쪽클릭
전체선택 더 빨라지게 할 수 있는 방법...inline?

바꾸기 시에 찾기 옵션도 적용되어야 한다. 지금 적용 안되어 있음(대소문자 구분, 단어단위로)
확대 축소 시 스크롤 포지션 조정이 필요하다.
확대 축소 시 자동줄바꿈 고려
형상관리, 주석, 프레임워크 그리기
마우스 휠 미끄럼틀처럼 만들어보기
SetPosition할 때도 조건을 주어 필요한 상황에서만 할 수 있도록
스크롤컨트롤러 클래스에서 Update와 SetPosition 알고리듬 수정
Delete 관련해서 OnSize가 너무 많이 일어나고 있는것 같아 확인 필요.
닫기버튼 눌렀을 때 메세지박스
스크롤 세부조정
테스트시나리오 보정 및 세부화
대용량파일 테스트 후 delete_scalar.cpp
_CRT_SECURITYCRITICAL_ATTRIBUTE
void __CRTDECL operator delete(void* const block) noexcept
{
    #ifdef _DEBUG
    _free_dbg(block, _UNKNOWN_BLOCK);
    #else
    free(block);
    #endif
}  오류 발생 중 언제/ 왜 발생하는지 정확히 모르는 상황.


오전 9:55 2023-05-19
<완료> 미리보기 창 띄울 때 메인윈도우 숨기기
오전 10:12 2023-05-12
위로 이관

오후 3:02 2023-05-09
#할 일 목록#
<완료> 자동줄바꿈시 unDoStack, reDoStack 모두 할당해제하기.

오전 9:33 2023-05-08
<완료> 메뉴에서 활성화 안된것들에 대해 단축키도 막기.

오후 11:03 2023-05-07
<완료> 수직스크롤 thumbtrack 내리다 보면 처음으로 돌아감. / 수평도 같은현상으로 둘다 해결완료, 16bit값이 들어와 32bit로 전환

오전 11:48 2023-05-04
<완료> 찾기모달리스다이얼로그 켰다고 끄고, 바꾸기 윈도우 키면 뻑남 / 반대로 해도 마찬가지. 다이얼로그 생성자에서 부모윈도우 설정 해주니 해결됨.
오후 12:54 2023-05-03

<완료> 마우스 창 밖으로 나갔을 때 클릭중 상태 아닌걸로 변경필요.
<완료> 자동줄바꿈상태에서 오른쪽 방향키 줄의 맨 마지막에서 눌렀을 때

오후 9:53 2023-05-01
<미해결> scrollController에서 SetPosition 고치기.
<미해결> Decorator 패턴 적용 고려. 일단은 안하는걸로.
<완료> 마우스 드래그할 때 스크롤 이동
<완료> MoveMouse에서 오버플로우 막기.
<완료> 경로가 없으며 수정됨 상태일 때 새로만들기누르고 다른이름으로 다이얼로그에서 취소 눌렀을 때 고치기
<완료> 더블버퍼링(MemoryDC) 기법을 사용하여 깜빡거림 없애기

오후 10:51 2023-04-23
<완료> 글꼴 크기 제한하기
<완료> 마우스 클릭 세부조정, 마우스로 선택하기
<완료> 열기, 저장, 새로만들기 등 하였을 때 unDo, reDoCommands 리셋 확인작업
<완료> 미선택 상태에서 잘라내기, 붙여넣기, 복사하기 실행취소 재실행 막기
<완료> 상태표시줄, 도움말
<완료> 클릭상태에서 마우스 이동 시 줄 이동할 때 previois 나 next말고 한번에 줄이동해야함.
<완료> CMenu포인터 너무 많이 잡지말고 리소스로 하라고 하셔서 가능하면 변경예정
<완료> 메뉴 실시간 업데이트 컨트롤러 필요할 것 으로 보임.
<완료> SetWindowText가 프레임윈도우의 캡션을 바꾸도록 수정필요.

오전 11:12 2023-04-23
<완료> 미리보기에서 인쇄하기 버튼 생성

오후 10:01 2023-04-22
<완료> 현재 프린트다이얼로그를 API로 띄우고 있어서 CPrintDialog로 변경시도.

오후 9:05 2023-04-22
<완료>CPrintDialog 나 CPageSetupDialog를 사용할 때 DoModal시 문제 해결방법
예시에서는 CPageSetupDialog나 CPrintDialog를 생성하고, Create 메시지를 보낸 뒤 DoModal 전에 

AFX_MANAGE_STATE(AfxGetStaticModuleState());
CoInitialize(NULL);
AfxEnableControlContainer();

를 입력하면 된다고 적혀 있었다.

오전 10:02 2023-04-20
<완료> 인쇄 2번이 안됨.

오후 4:16 2023-04-19
<완료> 미리보기 세세컨트롤(소수 곱하였을 때 짤리는부분 ㅠㅠㅠㅠ)
<완료> 미리보기 메뉴에서 인쇄하기 버튼 추가하기.


오후 10:48 2023-04-16
<위로 보냄>열기, 저장, 새창, 새로만들기 등 하였을 때 unDo, reDoCommands 리셋

오전 11:44 2023-04-13
<위로 보냄>미선택 상태에서 잘라내기, 붙여넣기, 복사하기 실행취소 재실행 막기

오후 11:00 2023-04-09
<완료>selectingbackspacekey / deletecommand로 메세지보내기

오후 4:58 2023-04-08
<완료>DeleteKeyCommand 클래스를 쪼개려고 한다.
먼저 DeleteKeyCommand에서 CharacterDeleteKeyCommand와 RowDeleteKeyCommand로 나눈다.
CharacterDeleteKeyCommand와 RowDeleteKeyCommand키는 unDoReDoCommand에 상속 받는다.
그 후 기본 생성자 및 unDoReDo를 위한 생성자를 만든다.


오후 12:51 2023-04-06
<위로 보냄>바꾸기 시에 찾기 옵션도 적용되어야 한다.
지금 적용 안되어 있음(대소문자 구분, 단어단위로)

ss오후 3:09 2023-04-05
<해결>실행취소 및 재실행 시 잔해가 남는 경우가 있는데 재현이 안된다.... // 실행취소 재현이 안된 기능을 쓰며 테스트해서 그랬었음


오전 9:18 2023-03-31h
<해결>선택중 OnImeComposition 매크로 커맨드가 바로 앞에 있으면 OnImeChar을 스택에 넣지 않는다. 이 조건문을 통해 해결해보자


bcd오전 3:33 2023-03-25
문제와 단서들	
 바꾸기에서 자동줄바꿈을 안했는데123 알아서됨.. 
알아보니 스크롤 관련 특정상황에서 SetScrollInfo를 할 때 OnSize 불러지는것 같음.
화면 크기를 조정할 때 조정한다고 무조건 Onsize가 불러지진 않고 자동줄바꿈 상태에서 화면크기를 조정하니 Onsize가 불러짐.
바꾸기에서 자동줄바꿈 해제 후 처리하는걸로 코드 수정 후에도 OnSize가 불러지는지 해보기<바꾸기 내에서 자동줄바꿈 하고 오니 안불러진다.>

5. Shift PageUp / Shift PageDown
1. 모두바꾸기
2. 찾기/바꾸기 자동줄바꿈과 같이 연계해서 문제점 수정.
11. 스크롤 세부조정
12. Decorator 패턴 적용 스크롤

<급한불>1. 마우스처리 드래그나 클릭
<완료> 2. 윈도우 최소크기 지정할 수 있으면 하자
<완료> 3. 실행취소가 필요한 기능 정리
<완료> 4. Paper쪽으로 GetIsSelecting를 옮겨서 Notepad에서 없애도 되면 없애자 (#if0 해놓고 paper로 다 돌려)
<완료> 5. 이전찾기, 다음찾기 메뉴 고치기. 다이얼로그(모달리스)가 꺼져 있는 상태라 pDlg가 Null인데 생각 및 처리가 필요한 상황
<완료> 6. SelectingDownKeyAction (DownKey에서 선택해제까지 추가) / SelectingUpKeyAction (UpKey에서 선택해제까지 추가) / SelectingHomeKeyAction(HomeKey에서 선택해제까지 추가) / 다 마찬가지 SelectingEndKeyAction / SelectingPageUp / SelectingPageDown
<완료> 7. 자동줄바꿈 상태에서 캐럿위치가 마지막으로 가지않고 다음 줄 첫번째로 가도록.
	LeftKey<완료> ,RightKeyAction<완료>, CtrlLeftKeyAction, CtrlRightKeyAction <자동줄바꿈해제하고 처리하기 때문에 문제없음>
<미완료> 8. Ctrl+→ / Ctrl+← KeyAction에서 자동줄바꿈을 안풀고도 할 수 있으면 안풀고 하자.
<완료> 9. 형상관리 + 주석
<완료> 10. 프레임워크 그리기.
<완료> 11. PageUpKeyAction, PageDownKeyAction 시 캐럿 이동하는 것으로 수정필요.


오전 10:08 2023-03-24
이전찾기, 다음찾기 메뉴 고치기. 다이얼로그(모달리스)가 꺼져 있는 상태라 pDlg가 Null인데 생각및 처리가 필요한 상황

오전 9:29 2023-03-23
FindNextCommand, FindPreviousCommand 수정
<완료> Notepad에 정의한 OnFindReplace의 내용을 FIndNextCommand와 FindPreviousCommand로 옮기고,
OnFindReplace에서는 SendMessage로 Command함수 호출하자.

<완료> 찾기바꾸기 다이얼로그를 끌 때 Notepad의 속성에 찾을내용과 바꿀내용을 저장을 하는데
끌 때 말고 OnFindReplace 함수 들어갈 때 돼야함.

<완료>Paper쪽으로 GetIsSelecting를 옮겨서 Notepad에서 없애도 되면 없애자 (#if0 해놓고 paper로 다 돌려)
<완료>윈도우 최소크기 지정할 수 있으면 하자
<위로보냄>마우스처리 드래그나 클릭

<완료> 0. Menu separator Caption (즐겨찾기 참고)
1. 모두바꾸기
2. 찾기/바꾸기 자동줄바꿈과 같이 연계해서 문제점 수정.
<완료> 3. 실행취소가 필요한 기능 정리
4. PageUpKeyAction, PageDownKeyAction 시 캐럿 이동하는 것으로 수정필요.
5. Shift PageUp / Shift PageDown
6. SelectingDownKeyAction / SelectingUpKeyAction / SelectingHomeKeyAction / SelectingEndKeyAction / SelectingPageUp / SelectingPageDown

7. 자동줄바꿈 상태에서 캐럿위치가 마지막으로 가지않고 다음 줄 첫번째로 가도록.
	LeftKey,RightKeyAction, CtrlLeftKeyAction, CtrlRightKeyAction에서 점검
8. Ctrl+→ / Ctrl+← KeyAction에서 자동줄바꿈을 안풀고도 할 수 있으면 안풀고 하자.
9. 형상관리 + 주석
10. 프레임워크 그리기.
11. 스크롤 세부조정
12. Decorator 패턴 적용 스크롤



오전 11:32 2023-03-21
오늘 바꾸기 기능 처리 후 자동줄바꿈시 찾기/바꾸기 기능 실헁해보자..
그리고 문제점 처리하기..

오후 5:18 2023-03-20
<완료> 마지막줄에서 UnSelect() 실헁할 때 뻑이 난다..
선택상태를 확인하는 함수가 Notepad에서 Paper로 옮겨져야 할 것 같고 선택중 상태이면
선택 해제해야 하는게 좋을것 같다.. 애초에 선택해제 함수자체가 선택된 상태를 전제로 하기때문에. 해결: Paper에 GetIsSelecting함수 생성 / Notepad에 있는건 아직 지우진 않음.

클래스 107개 / 12,400줄 

오전 2:37 2023-03-18

<완료> 1. 파일정리
<완료> 2. Ctrl Shift ↑ / Ctrl Shift ↓ / Ctrl Shift Home / Ctrl Shift End
<완료> 3. PageUpKeyAction, PageDownKeyAction 시 캐럿 이동하는 것으로 수정필요.
Shift PageUp / Shift PageDown

4. SelectingRightKeyAction / SelectingDownKeyAction / SelectingUpKeyAction /
SelectingHomeKeyAction / SelectingEndKeyAction / SelectingPageUp / SelectingPageDown

5. 자동줄바꿈 상태에서 캐럿위치가 마지막으로 가지않고 다음 줄 첫번째로 가도록.
	LeftKey,RightKeyAction, CtrlLeftKeyAction, CtrlRightKeyAction에서 점검
6. Ctrl+→ / Ctrl+← KeyAction에서 자동줄바꿈을 안풀고도 할 수 있으면 안풀고 하자.
7. 형상관리 + 주석
8. 프레임워크 그리기.
9. Decorator 패턴 적용 스크롤
10. 스크롤 세부조정


오후 5:13 2023-03-15
찾기바꾸기 다이얼로그는 Modeless dialog라 new연산자를 사용하여 힙에 할당해서 사용해야한다.


오후 11:12 2023-03-13
<완료> Ctrl C : command 패턴으로 옮기고 단축키만 추가 (메세지 보내기)

오후 12:35 2023-03-10
※할일 목록※

0. 선택하기.

PageUpKeyAction, PageDownKeyAction 시 캐럿 이동하는 것으로 수정필요.

Shift ↑ <완료> / Shift ↓ <완료> / Shift Home <완료> / Shift End <완료> / Shift PageUp / Shift PageDown
Ctrl A  <완료> / Ctrl Shift ↑ / Ctrl Shift ↓ / Ctrl Shift Home / Ctrl Shift End

SelectingRightKeyAction / SelectingDownKeyAction / SelectingUpKeyAction /
SelectingHomeKeyAction / SelectingEndKeyAction / SelectingPageUp / SelectingPageDown

<완료> 1. 형상관리
<완료> 2. 자동줄바꿈시 선택영역 모두해제.
		▶ 지금은 업데이트되어 선택영역해제 안됨...;;
<완료> 3. 처음 자동줄바꿈을 누를 때와 CtrlLeftKeyAction 실행 시 자동줄바꿈 후 다시 되었을 때 다름.
		▶뭔소린지 모르겠음. 잘 만 되는중
<완료> 4. OnChar과 OnImeComposition에서 각각 자동줄바꿈 순서가 다름
		▶차이를 확인하여 통일완료.
5. 자동줄바꿈 상태에서 캐럿위치가 마지막으로 가지않고 다음 줄 첫번째로 가도록.
	LeftKeyAction과 RightKeyAction, CtrlLeftKeyAction, CtrlRightKeyAction에서 점검
<완료> 6. 자동줄바꿈 상태에서 엔터를 입력했을 때 그 다음줄은 그냥 Row가 되어야하네.(OnChar)
		▶엔터시에도 자동줄바꿈 해제 및 다시 자동줄바꿈 해줌으로써 해결
7. Ctrl+→ / Ctrl+← KeyAction에서 자동줄바꿈을 안풀고도 할 수 있으면 안풀고 하자.
8. Decorator 패턴 적용 스크롤

<완료> 1. Glyph에서 RemoveSelectedTexts 추가
<완료> 2. Row에서 RemoveSelectedTexts 추가
<완료> 3. Glyph에서 RemoveSelectedRows 추가
<완료> 4. Paper에서 RemoveSelectedRows 추가
<완료> 5. SelectingBackSpaceKeyAction 추가
<완료> 6. KeyActionFactory에 SelectingBackSpaceKeyAction 추가


오후 9:20 2023-03-09
<완료> 선택영역 지우기 함수구현
<완료> 그 후 OnChar, OnImeComposition, OnImeChar 진행


오후 12:50 2023-03-09

※오늘 할일※

<완료> 1. 선택영역 시작위치로 이동 함수 정의
<완료> 2. 선택영역 해제 함수 정의
<완료> 3. 선택중 상태 확인 함수 검토
<완료> 4. SelectingLeftKeyAction 만들기.
	4.1. Notepad::GetIsSelecting 함수 정의
	4.2. Paper::MoveSelectingStartPoint 정의
	4.3. Paper::UnSelect 정의
	4.4. SelectingLeftKeyAction 정의
	4.5. KeyActionFactory에서 SelectingLeftKeyAction 포함시키기


오후 1:54 2023-03-08
<완료> 선택영역중 시작지점 찾기.
<완료> 선택영역중 끝 지점 찾기.
<완료> 선택영역 해제.
선택영역 지우기.

오후 6:28 2023-03-04
Ctrl+→ / Ctrl+← KeyAction에서 자동줄바꿈을 안풀고도 할 수 있으면 안풀고 하자.


오후 10:35 2023-03-02
1. PageUpKeyAction, PageDownKeyAction 시 캐럿 이동하는 것으로 수정필요.

오전 11:13 2023-02-28
<완료> 1. 계획한 스케쥴과 동일한 양식으로 실제 스케쥴 작성. 
<완료> 2. ScrollAction을 만들어서 HScroll이랑 VScroll 합치기.
<완료> 3. LeftKeyAction, RightKeyAction 처음에 적혀있던 문자 왜 구하는지? (이유 없어 보여 지움)
<완료> 4. 형상관리
<완료> 5. frame work 업데이트
<완료> 6. 자동줄바꿈 Wrap, UnWrap 알고리듬 점검 및 필요에 따라 수정. (문제없음)

7. 주말에 자동줄바꿈 디버깅 천천히 하면서 변수값들 정확히 일치하는지 보기.
<완료> 8. OnSize시에 캐럿위치가 이상함. (x, y좌표를 현재 적을위치에 맞게 수정함)
9. 자동줄바꿈 상태에서 캐럿위치가 마지막으로 가지않고 다음 줄 첫번째로 가도록.
	LeftKeyAction과 RightKeyAction, CtrlLeftKeyAction, CtrlRightKeyAction에서 점검
10. 자동줄바꿈 상태에서 엔터를 입력했을 때 그 다음줄은 그냥 Row가 되어야하네.(OnChar)
11. 처음 자동줄바꿈을 누른 후 CtrlLeftKeyAction 실행 시
	자동줄바꿈이 UnWrap 후 다시 Wrap이 되는데 형태가 바뀌어 확인이 필요해보임.
12. Decorator 패턴 적용 스크롤
13. 선택하기.
14. 자동줄바꿈 시에 문자 선택된 상태 확인 isSelected 상태



오후 3:03 2023-02-27
처음 자동줄바꿈을 누를 때와 CtrlLeftKeyAction 실행 시 자동줄바꿈 후 다시 자동줄바꿈이 되었을 때 다름.
OnChar에서는 먼저 자동줄바꿈 해제 하고 OnImeComposition에서는 나중에 자동줄바꿈해제 및 자동줄바꿈을하고 있다. 차이를 확인하여 통일이 가능하면 통일하자

오후 10:38 2023-02-25

자동줄바꿈 Wrap		//완료
자동줄바꿈 UnWrap 	//완료

짠 스케쥴과 동일한 양식으로 실제 스케쥴 작성.
☆금일 형상관리 결과
- LeftKeyAction, RightKeyAction 처음에 적혀있던 문자 왜 구하는지?
- OnHScroll, OnVScroll에서 caretController만 따로 업데이트 하는데
그냥 그 함수내에서 전체 업데이트 하면 될듯.
PageUpKeyAction, PageDownKeyAction  마찬가지

오후 3:37 2023-02-23
스크롤에 있는 함수들 Control에 해당하는 ScrollController로 이동시키기  //완료
frame work 업데이트
형상관리 하면서 스크롤, 자동개행 관리		//완료
caretcontroller만 따로 업데이트 하는부분 찾아서 Notify로 한번에 할 수 있으면 수정
ScrollAction을 만들어서 HScroll이랑 VScroll 합치기.
주말에 자동줄바꿈 디버깅 천천히 하면서 변수값들 정확히 일치하는지 보기.


오전 10:35 2023-02-20
Subject 배열에 Observer* 저장 시 ScrollController가 먼저 저장되어
있어야 할 것 같다. 왜냐하면 CaretController이 Scroll들의 값을 이용하여
출력 위치를 정하기 때문에.

확인결과: ScrollController는 Notepad의 OnCreate
에서 먼저 Attach 되며, CaretController는 Notepad의 SetFocus에서 Attach
되기 때문에 문제 없음.

또한 ScrollController에서 Notepad의 Invaildate를 호출하는데
여기에서는 빼고 각각의 함수에서 Invalidate를 시행 해줘야 할 것으로 보인다.
그렇지 않으면 OnSize등에서 Invalidate를 2번씩 하기 때문에.

나는 Notepad의 Notify에서 스크롤의 포지션도 위치가 업데이트가 되고 있어서,
Notepad의 OnSize에서도 Notify를 부르면 포지션의 위치가 변경되기 때문에
스크롤업데이트 코드는 따로 적고 캐럿만 업데이트 하는 방식으로 하려고 했으나,
선생님께서는 Notify를 부르고 포지션은 필요에 따라 조건식을 줘서 다른곳에서
바꿔주는 형식으로 해야 지옥을 안간다고 하심..

오후 4:59 2023-02-18
형상관리 하면서 테스트시나리오 적고, 시작 시 그 파일 열리기하기	// 완료
페이지업 다운 키 단축키												// 완료


오후 10:31 2023-02-16
스크롤 max를 글자길이 전체로 할지
			  글자길이 전체-페이지 로 할지 생각해봐야함.
무조건 max 는 글자길이 전체로 하고 page를 설정했어어야함....
textout visitor하면서 생각해보기.ㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇabcdㅇ


오후 4:46 2023-02-12
주석달기														//완료
종이에 파일명 있는데 필요한지 테스트 진행...						//완료

오전 10:06 2023-02-10
(Delete 키 구현)													//완료
BackSpace키 디버깅 해보기 (조립중 일 때OnKeyDown 발생X)		//완료
형상관리														//완료
Use Case 7. 끼워쓰기											//완료
객체지향설계													//완료
사용자 인터페이스 설계											//완료

[ 주말 진행예정 23-02-11 ~ 23-02-12]
Ctrl +'←', '→' 보완 필요 (previousWord / NextWord)				//완료
프레임워크 그리기
커맨트패턴 구조 수정(전략 패턴 관계처럼)							//완료
옵저버패턴 마찬가지.												//완료
비지터패턴 마찬가지.												//완료



2023-01-18
글자간 간격을 조정하여 한글자씩 출력을 했는데 왜 못했는지
다시 생각해보기.

오후 1:44 2023-02-05
1. tab키 눌렀을 때 특수문자가 나오는 문제
DrawText 에 format매개변수를 DT_EXPANDTAB을 사용하여 해결

형상관리하기.
UseCase5. 적을 위치를 옮기다.
사용자인터페이스 설계
프레임워크 그리기

오전 11:30 2023-02-07
폰트에서 좌표. 	//완료
형상관리 		// 완료
전략패턴(OnKeyDown) // 완료
'↑', '↓' 키 설계
Ctrl + '↑', '↓', '←', '→' 키 설계
커맨트패턴 구조 수정(전략 패턴 관계처럼)
프레임워크 그리기

오전 9:47 2023-02-08

형상관리														//완료
'↑', '↓' 기능추가													//완료
Ctrl + '↑', '↓', '←', '→','HOME','END' 키 설계							//완료

오후 12:48 2023-02-09
형상관리														//완료
Usecase 5. 한 문자 지우기										//완료
(BackSpace 키 구현)												//완료
(Delete 키 구현)													//완료 

테스트테스트테스트테스트테스트테스트테스트테스트테스트테스트테스트테스트테스트테